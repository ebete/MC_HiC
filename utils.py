#!/usr/bin/env python3

import logging
import sys
from glob import iglob

import pysam


def get_mapping_metadata(sam_input, ignore_ummapped=True, ignore_secondary=True):
    """
    Create a dictionary with the read id ("{Fq.Id}_{Rd.Id}") containing the alignment metadata from each fragment.

    The dictionary is structured as follows:

    {
      read_id: {
        fragment_id: {
          metadata_key: metadata_value
        }
      }
    }

    The keys in the metadata dictionary are created based on the header of the read. The following keys are likely to be
    extracted from the header:

    * Fq.Id: Source FASTQ UID
    * Rd.Id: Source read UID
    * Rd.Ln: Length of the source read
    * Fr.Id: Current fragment number of the read
    * Fr.Ln: Length of the fragment (Fr.Ln == Fr.En - Fr.St)
    * Fr.St: Zero-based start index of the fragment on the read (inclusive)
    * Fr.En: Zero-based end index of the fragment on the read (exclusive)

    These keys are added to the header of fragments that are created from existing alignments:

    * Src.Op: Operation that was executed to generate this fragment
    * Src.Fr: Comma-seperated list of Fr.Ids that were used to create this fragment
    * Src.Ln: Number of bases appended by the Src.Op operation

    The following keys are always added:

    * qname: The QNAME field of the alignment
    * clipping: A dictionary containing the read clipping operations
    * mapq: The MAPQ field of the alignment
    * aln_score: The value of the AS:i tag of the alignment
    * position: A dictionary containing the alignment position on the reference

    :type sam_input: str
    :param sam_input: The location of the SAM file to parse the metadata from.

    :type ignore_ummapped: bool
    :param ignore_ummapped: Whether to skip unmapped alignments

    :type ignore_secondary: bool
    :param ignore_secondary: Whether to skip secondary alignments

    :rtype dict
    :return: A dictionary containing the metadata for each read fragment.
    """
    alignments = dict()

    logging.info("Reading SAM file %s ...", sam_input)
    with pysam.AlignmentFile(sam_input, "r") as sam:
        for read in sam:
            if ignore_ummapped and read.is_unmapped:
                continue
            if ignore_secondary and read.is_secondary:
                continue

            metadata = read_header_to_dict(read.qname)
            metadata["clipping"] = unclipped_length(read.cigar)
            metadata["qname"] = read.qname
            metadata["mapq"] = read.mapq
            metadata["aln_score"] = read.get_tag("AS")
            metadata["position"] = {
                "chr": read.reference_name,
                "start": read.reference_start,
                "end": read.reference_end
            }

            read_id = make_read_id(metadata)
            fragment_id = int(metadata["Fr.Id"])

            alignments.setdefault(read_id, dict())[fragment_id] = metadata

    return alignments


def read_header_to_dict(header):
    """
    Map the metadata stored in the FASTA header to a dictionary.

    :type header: str
    :param header: The FASTA header as generated by fastq_subsample_and_merge.py

    :rtype dict
    :return: A dictionary representing the key-value pairs in the header
    """
    read_metadata = dict()
    for x in str(header).split(";"):
        read_metadata[x.split(":")[0]] = x.split(":")[1]
    return read_metadata


def unclipped_length(cigar_tuple):
    """
    Determine the unclipped length from the CIGAR data of the SAM alignment. Will return a dictionary with the alignment
    length.

    :type cigar_tuple: list
    :param cigar_tuple: CIGAR tuple list from a pysam alignment object.

    :rtype: dict
    :return: A dictionary containing the number of clipped bases on each end and the total unclipped length.
    """
    unclipped = 0
    start_clipping = cigar_tuple[0][1] if cigar_tuple[0][0] in {4, 5} else 0
    end_clipping = cigar_tuple[-1][1] if cigar_tuple[-1][0] in {4, 5} else 0
    for operation, length in cigar_tuple:
        if operation in {4, 5}:  # skip clipped
            continue
        unclipped += length
    return {"unclipped_length": unclipped, "clip_start": start_clipping, "clip_end": end_clipping}


def make_read_id(metadata):
    """
    Create an ID from the read metadata that is unique to the source read.

    :type metadata: dict
    :param metadata: Dictionary containing the metadata of the alignment.

    :rtype str
    :return: A unique read identifier.
    """
    return "{}_{}".format(metadata["Fq.Id"], metadata["Rd.Id"])


def glob_all_files(glob_files):
    """
    Create a list of the files that match the glob pattern.

    :type glob_files: list
    :param glob_files: List of file glob patterns.

    :rtype list
    :return: Flattened list of all matching files.
    """
    return [f for pattern in glob_files for f in iglob(pattern)]


def init_logger(log_level=logging.INFO):
    """
    Initialise the logger.

    :type log_level: int
    :param log_level: Set the minimum logging level.
    """
    logging.basicConfig(level=log_level, format="[%(asctime)s] %(message)s")


if __name__ == '__main__':
    print("This is not a runnable script.", file=sys.stderr)
